<br/>



<!-- tabs:start -->



#### **[ 普通函数 ]**

>[!WARNING|style: flat|label: 简要说明 ]
>
>- <span style='color:Blue'>[ 环境对象 ]</span> 是 [ 函数内部 ] 特殊的变量`this`<span style='color:red'>[ 代表：当前函数内部 - 运行时所处的环境 ]</span>
>
>   <span style='color:red'>[ 识别技巧：当前函数是由谁调用，那么函数内部`this`就指向谁 ]</span>
>
><br/>



```csharp
# this: window 
console.log(this)     

function M1()
{
     # [ 调用者：window ] this：window
     console.log(this) 
}

# [ 等效 ] window.M1()
M1()

-----------------------------------------
    
# [ 等效 ] window.setTimeout( ... )
setTimeout(function() {
  
    # [ 调用者：window ] this：window
    console.log(this);
}, 1000);


```

```csharp
const btn = document.getElementById('myButton');
btn.addEventListener('click', function() {

     # [ 调用者：按钮 ] this：btn
     console.log(this); 

});


```

```csharp
let obj = {

     Name: "李四",
     Age: 30,
     Print: function () {
         # [ 调用者：obj ] this：obj
         console.log(this);
     }

}

obj.Print(); 


```



#### **[ ℹ️ 箭头函数 ]**

!> <span style='color:red'>[ 箭头函数特殊，函数内部不绑定`this`；箭头函数内`this`由外层作用域确定，逐层向上查找最近作用域中的`this`]</span>

```csharp
console.log(this);     // window

# [ 箭头函数 ] 逐层向上查找作用域 ( this: window )
const M1 = () => {
    
    console.log(this); // this: window
}
M1()
    

```

```csharp
let obj = {
    
    Print: () => {
        # [ 箭头函数 ] 逐层向上查找作用域 ( this: window )
        console.log(this)
    },

    Print: function() {
       
        # [ 标准函数 ] this: 指向函数调用者 ( 因此 this = obj )
        console.log(this)
        var M1 = () => {
            
            # [ 箭头函数 ] 逐层向上查找作用域 ( this: obj )
            console.log(this)
        }
        M1();

    }

}

obj.Print()
    
    
```



#### **[ ✡ 内置函数 ] bind( ... )**

>[!WARNING|style: flat|label: 简要说明 ]
>
>- 在`JS`中，通过`bind`创建一个代理函数 <span style='color:red'>[ 作用：改变原函数内部的`this`指向 ] [ 无法改变箭头函数的`this`指向 ] [ 推荐 ]</span>
>
>  <span style='color:Blue'>[ 语法`function.bind(this, arg1, arg2, arg3 ...)`]</span>
>
>  <span style='color:Blue'>[ 参数`this`]</span> <span style='color:RED'>指定函数内部`this`指向</span>
>
>  <span style='color:Blue'>[ 参数`args`]</span> 函数参数 (`Array`)
>
><br/>

```csharp
let obj = {
    Name: "张三",
    Age: 30
}

function Print() {
    # bind：this = obj
    console.log(`Name: ${this.Name}, Age: ${this.Age}`);
}

---------------------------
    
# [ 代理函数 ] 函数内部作用域 this：obj
const proxyfn = Print.bind(obj);
console.log(typeof proxyfn); // function
proxyfn();                   // Name: 张三, Age: 30


```

```csharp
function TClass() {

    this.Print = function() {
        # bind：this = obj
        console.log(this);
    };

};

const obj = new TClass();

# [ 代理函数 ] 函数内部作用域 this：obj
const proxyfn = obj.Print.bind(window);
console.log(typeof proxyfn); // function
proxyfn(); 


```

```csharp
const btn = document.getElementById('myButton');
btn.addEventListener('click', function () {

    # [ 调用者：按钮 ] this：btn
    this.disabled = true;

    # [ 方案 1 ]
    window.setTimeout(() =>{
        # [ 箭头函数 ] 逐层向上查找作用域 ( this: btn )
        btn.disabled = false;
    }, 1000);

    # [ 方案 2 ]
    window.setTimeout(this, function() {
        # [ 代理函数 ] 函数内部作用域 this：btn
        btn.disabled = false;
    }.bind(this), 1000);

});


```





#### **[ ✡ 内置函数 ] apply( ... )**

>[!WARNING|style: flat|label: 简要说明 ]
>
>- 在`JS`中，通过`apply`立即调用函数 <span style='color:red'>[ 作用：改变函数内部的`this`指向 ] [ 无法改变箭头函数的`this`指向 ]</span>
>
>  <span style='color:Blue'>[ 语法`function.apply(this, [args])`]</span>
>
>  <span style='color:Blue'>[ 参数`this`]</span> <span style='color:RED'>指定函数内部`this`指向</span>
>
>  <span style='color:Blue'>[ 参数`args`]</span> 函数参数 (`Array`)
>
><br/>

```csharp
let obj = {

    # apply：this = window
    Print: function(x, y) {
        console.log(this)
        console.log(x + y)
    }
    
}

# [ 改变函数内部作用域 ] this：window
obj.Print.apply(window, [2, 3])  
    
    
```

```csharp
function TClass() {

    # apply：this = window
    this.Print = function() {

        console.log(this);
    };

};

# [ 改变函数内部作用域 ] this: window
const o = new TClass();
o.Print.apply(window);


```







<!-- tabs:end -->

