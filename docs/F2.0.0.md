<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>- <span style='color:Blue'>[ 环境对象 ]</span> 是 [ 函数内部 ] 特殊的变量`this`<span style='color:red'>[ 代表：当前函数运行时所处的环境 ]</span>
>
>   <span style='color:red'>[ 判断标准：谁调用的函数`this`就是指向谁 ]</span>
>
><br/>



<!-- tabs:start -->



#### **[ 标准函数 ]**



```csharp
# 【 案例 A 】
function M1()
{
    console.log(this) // this: window 
}

M1() // 等效: window.M1()


```

```csharp
# 【 案例 B 】
const btn = document.getElementById('myButton');
btn.addEventListener('click', function() {

    # [ 因按钮调用 ] this：指向 btn 当前按钮
    console.log(this); 

});


```

```csharp
# 【 案例 C 】
let obj = {

    Name: "李四",
    Age: 30,
    Print: function () {
        // this: obj 
        console.log(this);
    }

}

obj.Print(); 


```



#### **[ ✡ 箭头函数 ]**

!> <span style='color:red'>[ 箭头函数特殊，不绑定`this`: 因此，箭头函数内`this`指向上一级作用域的`this`]</span>

```csharp
console.log(this);     // window

# 箭头函数 this 指向上一级是 window
const M1 = () => {
    
    console.log(this); // this: window
}
M1()
    

```

!> <span style='color:red'>[ 以字面量方式声明对象： 函数内的`this`指向上一级`window`]</span> [<span style='color:#008B00'>[👓 Q1 ]</span>](o1.0.0 ':target=_blank')

```csharp
console.log(this); // window
let obj = {
    
    Print1: () => {
        // this: window
        console.log(this)
        var M1 = () => {
            // this: window
            console.log(this)
        }
        M1();

    },

    Print2: function() {
       
        # [ 标准函数 ] this: obj
        console.log(this)
        var M1 = () => {
            
            # 箭头函数 this 指向上一级是 obj ( this: obj )
            console.log(this)
        }
        M1();

    }

}

obj.Print1()
obj.Print2()
    
    
```





<!-- tabs:end -->

