<br/>

<!-- tabs:start -->

#### **[ 变量概述 ]**



>[!WARNING|style: flat|label: 简要说明 ]
>
><span style='color:Blue'>[ 变量声明 ]</span>
>
>- <span style='color:RED'>[ 变量声明`let`] 块作用域 ( 禁止重复声明 )</span>
>
>- <span style='color:RED'>[ 常量声明`const`] 块作用域 ( 声明必须初始化 ) </span>
>
>  <span style='color:red'>[ ℹ️ 变量作用域链：当访问一个变量时，引擎会从当前作用域开始，逐级向上查找，直到找到变量或到达全局作用域 ]</span>
>
>  <span style='color:red'>[ ℹ️ 最佳推荐：如果变量可变使用`let`- 针对引用类型`const`锁定的是变量的地址 ]</span>
>
></br>

```csharp
# [ 全局变量 ]
let x = "张三"
// let x = "李四" -- 不可重复声明

function M1() {

    if (true) {

         # [ 局部变量 ]
         let x = 2, 
             y = 3

         console.log(x)  // 2 ( 局部 )
         console.log(y)  // 3

    }

    console.log(x)    // 张三 ( 全局 )
    // console.log(y) - Error：ReferenceError: y is not defined

}

M1()
console.log(x)  // 张三 ( 全局 )


```



#### **[ ✡ 数组解构 ]**

>[!WARNING|style: flat|label: 简要说明 ]
>
>数组解构是指将 [ 数组中的元素 → 分别赋值给多个变量 ]
>
>- <span style='color:red'>数组中的元素数量必须与变量数量匹配 ( 在`JS`中，宽松匹配，不匹配的变量赋予`undefined | []` )</span>
>- <span style='color:red'>[ 使用：`_`弃元模式，`...`获取剩余元素 ]</span>
>
><br/>

```csharp
const [x, _, z, ...vs] = [1, 2, 3, 4, 5];

console.log(x);   // 1
console.log(z);   // 3
console.log(vs);  // [ 4, 5 ] 在JS 中剩余元素必须放在最后


```

```csharp
# [ 案例 ] 交换变量值
let a = 1, b = 2;
[a, b] = [b, a];
console.log(a, b); 


```





<!-- tabs:end -->

