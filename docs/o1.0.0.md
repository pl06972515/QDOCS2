<br/>



<!-- tabs:start -->

#### **[  构造函数 ] **

!> <span style='color:red'>[ 构造函数 ] 在`JS`中，构造函数是一种特殊的函数 ( 常用：创建对象 ) [ 函数名称约定: 首字母大写 ]</span>

```csharp
function TClass(name, age) {
    
    this.Name = name;
    this.Age = age;

    # [ 箭头函数 ] 逐层向上查找作用域 ( this: obj ) [ 因构造函数内部： this 指向实列对象 ]
    this.Print = () => {
        
        console.log(`姓名：${this.name}，年龄：${this.age}`);
    };
    
};

# [ 静态成员 ]
TClass.FileName = "Index.js";

# [ A ] [ 箭头函数 ] 逐层向上查找作用域 ( this: window )
TClass.Show2 = () => {
    console.log(this); // this = window
    console.log(`文件名：${TClass.FileName}`);
}

# [ B ] [ 标准函数 ] this: 指向函数调用者 ( 因此 this: TClass )
TClass.Show1 = function() {
    console.log(this); // this = TClass
    console.log(`文件名：${TClass.FileName}`);
}

-------------------------------------
    
/// <summary>
/// new 操作符的执行过程
/// [ A ] 创建一个新的空对象 {}
/// [ B ] [ this 绑定 ] 构造函数内部 this 指向这个对象
/// [ C ] 执行构造函数 [ 传递参数：为该对象添加属性和方法 ]
/// [ D ] 返回对象( 引用 )
///
/// </summary>
const u1 = new TClass("张三", 20);
console.log(u1.Name); // 张三
console.log(u1.Age);  // 20
u1.Print();

const u2 = new TClass("李四", 30);
console.log(u2.Name); // 李四
console.log(u2.Age);  // 30
u2.Print();


```



#### **[ ✡ 原型对象 + 对象原型 ]**

>[!WARNING|style: flat|label: 简要说明 ]
>
>- [`A`] 在`JS`中，<span style='color:Blue'>[ 构造函数 ]</span> 都有一个`prototype`属性 <span style='color:red'>[ 其指向一个 - 原型对象 ]</span>
>
>   <span style='color:red'>[ 原型对象：都会一个`Prototype.constructor`属性，其指向与其关联的 - 构造函数 ]</span>
>
>
> <br/>
>
>- <span style='color:red'>[`B`] [ 对象原型 ] 在`JS`中，对象实例都会有一个属性 [`__proto__`指向：该构造函数的原型对象`prototype`] </span>
>
>   <span style='color:red'>[ 共享原型：该构造函数创建的所有对象实例 - 共享同一个原型对象，因此可以调用原型对象的属性和方法 ]</span>
>
>  ⚠ <span style='color:red'>[`__proto__`是只读的非`JS`标准属性，因此有些浏览器是`[[proto]] = __proto__` ]</span>
>
>  ⚠ <span style='color:red'>[ 内存优化：将构造函数内方法定义在原型上 - 可避免每个对象实例都创建一份函数副本 ]</span>
>
>
><br/>
>
>![o1.0.0](wwwroot\DocImages\o1.0.0.png ':size=600')
>
>
>
><br/>

```csharp
function TClass(name, age) {
    # [ 公共属性 ]
    this.Name = name;
    this.Age = age;
};

-----------------------------------------------
  
# [ 公共方法 ] prototype
TClass.prototype = {
    
    # [ 注意事 ] 原型对象的 constructor 需手动指向 TClass
    constructor: TClass,
    
    # [ 1 ] [ 箭头函数 ] 逐层向上查找作用域 ( this: window )
    Print1: () => {
        console.log(this); // this = window
    },
    # [ 2 ] [ 标准函数 ] this: 指向函数调用者 ( 因此 this = u1 )
    Print2: function () {
        console.log(this); // this = u1
        console.log(`姓名：${this.Name}，年龄：${this.Age}`);
    }
    
};

-----------------------------------------------
    
const u1 = new TClass("张三", 20);
console.log(u1.Name); // 张三
console.log(u1.Age);  // 20
u1.Print2();

console.log(TClass.prototype.constructor === TClass); // true
console.log(u1.__proto__ === TClass.prototype);       // true

console.log(TClass.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null);             // true


```

>```csharp
># [ 案例 ] 扩展方法
>Array.prototype.Sum = function () {
>     // this = Array
>     return this.reduce((acc, val) => acc + val, 0);
>};
>
>console.log([1, 2, 3, 4, 5].Sum()); // Output: 15
>    
>```
>
>



<!-- tabs:end -->

