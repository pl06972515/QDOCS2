<br/>



<!-- tabs:start -->

#### **[  构造函数 ] **

!> <span style='color:red'>[ 构造函数 ] 在`JS`中，构造函数是一种特殊的函数 ( 用于创建和初始化对象 )</span>

```csharp
# [ 构造函数 ] 名称约定: 首字母大写
function TClass(name, age) {
    
    this.Name = name;
    this.Age = age;

    # [ 注意事项 ] 箭头函数 this 指向上一级是`实列对象`
    this.Print = () => {
        
        console.log(`姓名：${this.name}，年龄：${this.age}`);
    };
    
};

# [ 静态成员 ]
TClass.FileName = "Index.js";

# [ A ] 箭头函数 this 指向上一级是 window
TClass.Show2 = () => {
    console.log(this); // this = window
    console.log(`文件名：${TClass.FileName}`);
}

# [ B ] 标准函数 this: 指向函数调用者 ( 因此 this = TClass )
TClass.Show1 = function() {
    console.log(this); // this = TClass
    console.log(`文件名：${TClass.FileName}`);
}

-------------------------------------
    
/// <summary>
/// new 操作符的执行过程
/// [ A ] 创建一个新的空对象 {}
/// [ B ] [ this 绑定 ] 构造函数内部 this 指向这个对象
/// [ C ] 执行构造函数 [ 传递参数：为该对象添加属性和方法 ]
/// [ D ] 返回对象( 引用 )
///
/// </summary>
const u1 = new TClass("张三", 20);
console.log(u1.Name); // 张三
console.log(u1.Age);  // 20
u1.Print();

const u2 = new TClass("李四", 30);
console.log(u2.Name); // 李四
console.log(u2.Age);  // 30
u2.Print();


```



#### **[ ℹ️ 原型对象 ] Prototype**

>[!WARNING|style: flat|label: 简要说明 ]
>
>- 在`JS`中，[ 构造函数 ] 都有一个`prototype`属性 <span style='color:red'>[ 其指向一个 - 原型对象 ]</span>
>
>  <span style='color:red'>[ 共享性：构造函数创建的所有对象实例 - 共享同一个原型对象 ] [ 因此：该对象可以访问原型对象的成员 ]</span>
>
>  <span style='color:red'>[ 内存优化：类型方法定义在原型上( 可避免每个实例都创建一份函数副本 ) 构造函数和原型对象中的`this`都指向`对象实例`]</span>
>
>- <span style='color:red'>[ 原型对象都会一个`Prototype.constructor`属性，其指向：与其关联的构造函数 ]</span>
>
>![image-20251120150612196](wwwroot\DocImages\image-20251120150612196.png)
>
><br/>

```csharp
function TClass(name, age) {
    # [ 公共属性 ]
    this.Name = name;
    this.Age = age;
};

-----------------------------------------------
    
# [ A ][ 公共方法 ] prototype
# [ 1 ] 箭头函数 this 指向上一级是 window
TClass.prototype.Print1 = () => {
    console.log(this); // this = window
};

# [ 2 ] 标准函数 this: 指向函数调用者 ( 因此 this = u1 )
TClass.prototype.Print2 = function(){
    console.log(this); // this = u1
    console.log(`姓名：${this.Name}，年龄：${this.Age}`);
};

-----------------------------------------------
    
# [ B ][ 公共方法 ] prototype
TClass.prototype = {
    
    # [ 注意事 ] 原型对象的 constructor 必须从新指向 TClass
    constructor: TClass,
    
    # [ 1 ] 箭头函数 this 指向上一级是 window
    Print1: () => {
        console.log(this); // this = window
    },
    # [ 2 ] 标准函数 this: 指向函数调用者 ( 因此 this = u1 )
    Print2: function () {
        console.log(this); // this = u1
        console.log(`姓名：${this.Name}，年龄：${this.Age}`);
    }
    
};

-----------------------------------------------
    
const u1 = new TClass("张三", 20);
console.log(u1.Name); // 张三
console.log(u1.Age);  // 20
u1.Print2();


```

>```csharp
># [ 案例 ] 扩展方法
>Array.prototype.Sum = function () {
>     // this = Array
>     return this.reduce((acc, val) => acc + val, 0);
>};
>
>console.log([1, 2, 3, 4, 5].Sum()); // Output: 15
>    
>```
>
>



#### **[ ℹ️ 对象原型 ] __proto__**

>[!WARNING|style: flat|label: 简要说明 ]
>
>- 在`JS`中，对象实例都会有一个属性 [`__proto__`] 
>
>  [`A`] <span style='color:red'>[`__proto__`指向：该构造函数的`prototype` - 因此可以调用原型对象的属性和方法 ]</span>
>
>  [`B`] <span style='color:red'>[`__proto__.constructor`指向：该构造函数 ]</span>
>
>  <span style='color:red'>[ 注意事项：`__proto__`是只读的非`JS`标准属性，因此有些浏览器是`[[proto]] = __proto__` ]</span>
>
>![image-20251120155016810](wwwroot\DocImages\image-20251120155016810.png)
>
><br/>

```csharp
function TClass(name, age) {
    this.Name = name;
    this.Age = age;
};

# [ A ]
console.log(TClass.prototype.constructor === TClass); // true

# [ B ]
let u1 = new TClass("张三", 20);
console.log(u1.__proto__ === TClass.prototype);       // true
console.log(u1.__proto__.constructor === TClass);     // true


```





<!-- tabs:end -->

